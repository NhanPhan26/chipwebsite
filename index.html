<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MQTT Toggle — Simple</title>
  <style>
    :root{
      --bg:#071025; --card:#071827; --muted:#9aa4b2; --on:#10b981; --off:#cbd5e1;
      --glass: rgba(255,255,255,0.02);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%}
    body{
      margin:0; background:linear-gradient(180deg,#041021,#071025); color:#e6eef6;
      display:flex; align-items:center; justify-content:center; padding:20px;
    }
    .card{
      width:360px; max-width:95vw; border-radius:12px; padding:18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 8px 30px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03);
      text-align:center;
    }
    h1{margin:0;font-size:18px}
    p.lead{margin:8px 0 18px;color:var(--muted);font-size:13px}
    /* Toggle */
    .switch {
      --w:96px; --h:48px;
      width:var(--w); height:var(--h); border-radius:28px; position:relative;
      background:rgba(255,255,255,0.04); padding:6px; box-sizing:border-box;
      display:inline-block; transition:background .16s ease, opacity .16s;
      cursor:pointer;
    }
    .switch[aria-disabled="true"]{ opacity:0.45; cursor:not-allowed; }
    .switch[data-on="true"]{ background: linear-gradient(90deg, rgba(16,185,129,0.18), rgba(6,182,212,0.08)); }
    .knob { width:36px;height:36px;border-radius:50%;background:white;transform:translateX(0); transition: transform .16s cubic-bezier(.2,.9,.3,1) }
    .switch[data-on="true"] .knob { transform: translateX(48px); }
    .label { margin-top:12px; font-weight:700; font-size:16px; }
    .status { margin-top:8px; font-size:13px; color:var(--muted); }
    .small { font-size:12px; color:var(--muted) }
  </style>
</head>
<body>
  <div class="card">
    <h1>Điều khiển đèn (MQTT)</h1>
    <p class="lead">Chỉ 1 công tắc — tự kết nối tới HiveMQ Cloud</p>

    <!-- Toggle -->
    <div id="toggle" class="switch" role="button" tabindex="0"
         data-on="false" aria-pressed="false" aria-disabled="true">
      <div class="knob"></div>
    </div>

    <div id="label" class="label">Đèn: <span id="lightState">Unknown</span></div>
    <div id="status" class="status">Trạng thái kết nối: <strong>Chưa kết nối</strong></div>

    <!-- Hidden config (for reference) -->
    <!--
      Broker: wss://5ddabd57e04648cf9b89ed05225e9ddc.s1.eu.hivemq.cloud:8884/mqtt
      Username: phannhan2612oz
      Password: Thanhnhan003
      Topic: turn_light
    -->
  </div>

  <!-- mqtt.js -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script>
    // ---------- CONFIG (pre-filled) ----------
    const BROKER_URL = 'wss://5ddabd57e04648cf9b89ed05225e9ddc.s1.eu.hivemq.cloud:8884/mqtt';
    const USERNAME = 'phannhan2612oz';
    const PASSWORD = 'Thanhnhan003';
    const TOPIC = 'turn_light';
    const QOS = 0; // 0 is fine for simple toggle

    // ---------- UI refs ----------
    const toggle = document.getElementById('toggle');
    const lightStateEl = document.getElementById('lightState');
    const statusEl = document.getElementById('status');
    const labelEl = document.getElementById('label');

    // ---------- State ----------
    let client = null;
    let connected = false;
    let deviceState = null; // 'ON' or 'OFF' or null

    function setToggleEnabled(enabled) {
      toggle.setAttribute('aria-disabled', enabled ? 'false' : 'true');
      // pointer events controlled by CSS via opacity, no further changes needed
    }

    function setConnectionStatus(text, ok) {
      statusEl.innerHTML = 'Trạng thái kết nối: <strong>' + text + '</strong>';
      setToggleEnabled(Boolean(ok));
    }

    function setDeviceState(state, info) {
      deviceState = state;
      if (state === 'ON') {
        toggle.setAttribute('data-on', 'true');
        toggle.setAttribute('aria-pressed', 'true');
        lightStateEl.innerText = 'BẬT';
        lightStateEl.style.color = '#9be6c7';
      } else if (state === 'OFF') {
        toggle.setAttribute('data-on', 'false');
        toggle.setAttribute('aria-pressed', 'false');
        lightStateEl.innerText = 'TẮT';
        lightStateEl.style.color = '#cbd5e1';
      } else {
        toggle.setAttribute('data-on', 'false');
        toggle.setAttribute('aria-pressed', 'false');
        lightStateEl.innerText = 'Unknown';
        lightStateEl.style.color = '#cbd5e1';
      }
      if (info) {
        labelEl.title = info;
      }
    }

    // ---------- MQTT ----------
    function createClientAndConnect() {
      addSmallConsole('Tạo client, kết nối tới ' + BROKER_URL);
      try {
        client = mqtt.connect(BROKER_URL, {
          clientId: 'web_toggle_' + Math.floor(Math.random()*10000),
          username: USERNAME,
          password: PASSWORD,
          reconnectPeriod: 3000,
          connectTimeout: 30 * 1000,
          keepalive: 20,
          clean: true,
        });
      } catch (e) {
        addSmallConsole('Lỗi tạo client: ' + e);
        setConnectionStatus('Lỗi tạo client', false);
        return;
      }

      client.on('connect', () => {
        connected = true;
        setConnectionStatus('Đã kết nối', true);
        addSmallConsole('Connected, subscribing to ' + TOPIC);
        client.subscribe(TOPIC, {qos: QOS}, (err) => {
          if (err) {
            addSmallConsole('Subscribe error: ' + err);
          } else {
            addSmallConsole('Subscribed to ' + TOPIC);
          }
        });
        // ask for last will? (no) We wait for device to publish its status.
      });

      client.on('reconnect', () => {
        connected = false;
        setConnectionStatus('Đang kết nối lại...', false);
      });

      client.on('close', () => {
        connected = false;
        setConnectionStatus('Đã ngắt', false);
      });

      client.on('offline', () => {
        connected = false;
        setConnectionStatus('Offline', false);
      });

      client.on('error', (err) => {
        addSmallConsole('MQTT error: ' + (err && err.message ? err.message : err));
        // allow reconnect
      });

      client.on('message', (topic, payload) => {
        const msg = payload.toString();
        addSmallConsole('Received: ' + msg + ' from ' + topic);
        if (msg === 'ON' || msg === 'OFF') {
          setDeviceState(msg, 'Updated from topic ' + topic);
        } else {
          // if device sends other payloads, ignore or show unknown
          setDeviceState(null, 'Last message: ' + msg);
        }
      });
    }

    function publishState(state) {
      if (!client || !connected) {
        addSmallConsole('Không gửi được - chưa kết nối');
        return;
      }
      client.publish(TOPIC, String(state), {qos: QOS}, (err) => {
        if (err) addSmallConsole('Publish error: ' + err);
        else addSmallConsole('Published: ' + state);
      });
    }

    // ---------- UI interactions ----------
    function toggleAction() {
      if (toggle.getAttribute('aria-disabled') === 'true') {
        // disabled, ignore
        return;
      }
      // compute next state
      const currentlyOn = toggle.getAttribute('data-on') === 'true';
      const next = currentlyOn ? 'OFF' : 'ON';
      // optimistic UI change (we could wait for device reply, but UX better to reflect immediately)
      setDeviceState(next, 'Sending ' + next);
      publishState(next);
    }

    toggle.addEventListener('click', toggleAction);
    toggle.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); toggleAction(); }
    });

    // small invisible console for dev (kept minimal, not shown)
    function addSmallConsole(msg) {
      console.log('[mqtt-toggle] ' + msg);
    }

    // ---------- Init ----------
    setToggleEnabled(false);
    setConnectionStatus('Chưa kết nối', false);
    setDeviceState(null, 'Waiting for device');

    // auto connect once
    setTimeout(() => { createClientAndConnect(); }, 300);

    // clean unload
    window.addEventListener('beforeunload', () => {
      if (client && client.end) client.end(true);
    });
  </script>
</body>
</html>
